import { HJXAst, HJXNode } from "../types.js";
import { LoadedComponent } from "../loader.js";
import { scopeCss } from "./vanilla_scope_css.js";

export function buildServerDriven(tree: LoadedComponent): { html: string; css: string; js: string } {
  const cssParts = new Map<string, string>();

  function collectCss(comp: LoadedComponent) {
    const scope = `hjx-${comp.ast.component.name.toLowerCase()}`;
    if (!cssParts.has(scope)) {
      cssParts.set(scope, scopeCss(comp.ast.style ?? "", scope));
    }
    for (const child of Object.values(comp.imports)) {
      collectCss(child);
    }
  }
  collectCss(tree);
  const css = Array.from(cssParts.values()).join("\n");

  const { htmlBody, bindings, attrBindings, eventBindings, inputBindings } = renderComponent(tree, "");

  // We don't compile handlers to JS here because they run on the server.
  // We just need the initial state structure for potential hydration,
  // though the server will send the authoritative state on connection.
  const initialState = "{}"; // Client starts empty, gets state from server

  const js = `// Generated by HJX v0.1 (server-driven)
import { createRemoteStore, textBinder, attrBinder, clickBinder, inputBinder } from "./runtime.js";

const initialState = ${initialState};

export function createApp(rootEl) {
  // Auto-connect to the server origin via WebSocket
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const wsUrl = protocol + "//" + location.host + "/hjx";

  const store = createRemoteStore(wsUrl, initialState);

  // bind text interpolations
  ${bindings.map((b) => `textBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind attributes
  ${attrBindings.map((b) => `attrBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.attr)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind clicks
  // Instead of executing a local handler, we send an event to the server
  ${eventBindings.map((e) => `clickBinder(store, rootEl, ${JSON.stringify(e.selector)}, () => store.sendEvent(${JSON.stringify(e.handler)}));`).join("\n  ")}

  // bind inputs (2-way)
  ${inputBindings.map((b) => `inputBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.stateKey)});`).join("\n  ")}

  return { store };
}

export function mountApp() {
  const root = document.getElementById("app");
  if (!root) throw new Error("Missing #app");
  // root scope is main component
  root.setAttribute("data-hjx-scope", ${JSON.stringify(`hjx-${tree.ast.component.name.toLowerCase()}`)});
  root.innerHTML = ${JSON.stringify(htmlBody)};
  createApp(root);
}

mountApp();
`;

  // We need a modified runtime that supports RemoteStore
  const runtime = serverDrivenRuntimeJS();

  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${escapeHtml(tree.ast.component.name)}</title>
  <link rel="stylesheet" href="./app.css"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            border: "hsl(var(--border))",
            input: "hsl(var(--input))",
            ring: "hsl(var(--ring))",
            background: "hsl(var(--background))",
            foreground: "hsl(var(--foreground))",
            primary: {
              DEFAULT: "hsl(var(--primary))",
              foreground: "hsl(var(--primary-foreground))",
            },
            secondary: {
              DEFAULT: "hsl(var(--secondary))",
              foreground: "hsl(var(--secondary-foreground))",
            },
            destructive: {
              DEFAULT: "hsl(var(--destructive))",
              foreground: "hsl(var(--destructive-foreground))",
            },
            muted: {
              DEFAULT: "hsl(var(--muted))",
              foreground: "hsl(var(--muted-foreground))",
            },
            accent: {
              DEFAULT: "hsl(var(--accent))",
              foreground: "hsl(var(--accent-foreground))",
            },
            popover: {
              DEFAULT: "hsl(var(--popover))",
              foreground: "hsl(var(--popover-foreground))",
            },
            card: {
              DEFAULT: "hsl(var(--card))",
              foreground: "hsl(var(--card-foreground))",
            },
          },
          borderRadius: {
            lg: "var(--radius)",
            md: "calc(var(--radius) - 2px)",
            sm: "calc(var(--radius) - 4px)",
          },
        },
      },
    }
  </script>
  <style>
    :root {
      --background: 0 0% 100%;
      --foreground: 222.2 84% 4.9%;
      --card: 0 0% 100%;
      --card-foreground: 222.2 84% 4.9%;
      --popover: 0 0% 100%;
      --popover-foreground: 222.2 84% 4.9%;
      --primary: 222.2 47.4% 11.2%;
      --primary-foreground: 210 40% 98%;
      --secondary: 210 40% 96.1%;
      --secondary-foreground: 222.2 47.4% 11.2%;
      --muted: 210 40% 96.1%;
      --muted-foreground: 215.4 16.3% 46.9%;
      --accent: 210 40% 96.1%;
      --accent-foreground: 222.2 47.4% 11.2%;
      --destructive: 0 84.2% 60.2%;
      --destructive-foreground: 210 40% 98%;
      --border: 214.3 31.8% 91.4%;
      --input: 214.3 31.8% 91.4%;
      --ring: 222.2 84% 4.9%;
      --radius: 0.5rem;
    }
    .dark {
      --background: 222.2 84% 4.9%;
      --foreground: 210 40% 98%;
      --card: 222.2 84% 4.9%;
      --card-foreground: 210 40% 98%;
      --popover: 222.2 84% 4.9%;
      --popover-foreground: 210 40% 98%;
      --primary: 210 40% 98%;
      --primary-foreground: 222.2 47.4% 11.2%;
      --secondary: 217.2 32.6% 17.5%;
      --secondary-foreground: 210 40% 98%;
      --muted: 217.2 32.6% 17.5%;
      --muted-foreground: 215 20.2% 65.1%;
      --accent: 217.2 32.6% 17.5%;
      --accent-foreground: 210 40% 98%;
      --destructive: 0 62.8% 30.6%;
      --destructive-foreground: 210 40% 98%;
      --border: 217.2 32.6% 17.5%;
      --input: 217.2 32.6% 17.5%;
      --ring: 212.7 26.8% 83.9%;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    // Inline runtime module
    ${runtime}
  </script>
  <script type="module" src="./app.js"></script>
</body>
</html>
`;

  return { html, css, js: js + "\n\n// NOTE: also emit runtime.js in output.\n" };
}

function escapeHtml(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function emptyRoot(): HJXNode {
  return {
    kind: "node", tag: "view", id: "root", classes: [], attrs: {}, text: null, events: {}, bind: null, children: [
      { kind: "node", tag: "text", classes: [], attrs: {}, text: "Empty layout", events: {}, bind: null, children: [] }
    ]
  };
}

type Bindings = {
  htmlBody: string;
  bindings: Array<{ selector: string; template: string }>;
  attrBindings: Array<{ selector: string; attr: string; template: string }>;
  eventBindings: Array<{ selector: string; handler: string }>;
  inputBindings: Array<{ selector: string; stateKey: string }>;
};

function renderComponent(
  comp: LoadedComponent,
  statePrefix: string,
  extraAttrs: Record<string, string> = {},
  extraEvents: Record<string, string> = {},
  slots: Record<string, Bindings> = {},
  ctx: { autoId: number } = { autoId: 0 }
): Bindings {
  const scope = `hjx-${comp.ast.component.name.toLowerCase()}`;
  return renderNode(comp.ast.layout ?? emptyRoot(), scope, comp.imports, statePrefix, extraAttrs, extraEvents, slots, ctx);
}

function renderNode(
  node: HJXNode,
  scope: string,
  imports: Record<string, LoadedComponent>,
  statePrefix: string,
  extraAttrs: Record<string, string> = {},
  extraEvents: Record<string, string> = {},
  receivedSlots: Record<string, Bindings> = {},
  ctx: { autoId: number }
): Bindings {
  const bindings: Array<{ selector: string; template: string }> = [];
  const attrBindings: Array<{ selector: string; attr: string; template: string }> = [];
  const eventBindings: Array<{ selector: string; handler: string }> = [];
  const inputBindings: Array<{ selector: string; stateKey: string }> = [];

  // 1. Handle <slot> element
  if (node.tag === "slot") {
    const slotName = node.attrs["name"] || "default";
    const slotData = receivedSlots[slotName];

    if (slotData && slotData.htmlBody) {
      // Return bindings from slot data
      return slotData;
    }
  }

  // Check if node tag is an imported component
  if (imports[node.tag]) {
    const childComp = imports[node.tag];
    const instanceId = ctx.autoId++;
    const childKey = `${node.tag}_${instanceId}`;
    const childPrefix = statePrefix ? `${statePrefix}.${childKey}` : childKey;

    // Rewrite props/attrs
    const childProps: Record<string, string> = {};
    for (const [k, v] of Object.entries({ ...node.attrs, ...extraAttrs })) {
      if (v.includes("{{")) {
        childProps[k] = v.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, key) => {
          if (extraAttrs[key]) return extraAttrs[key];
          return `{{${statePrefix ? statePrefix + "." + key : key}}}`;
        });
      } else {
        childProps[k] = v;
      }
    }

    // Rewrite events
    const childEvents: Record<string, string> = {};
    for (const [evt, handler] of Object.entries(node.events ?? {})) {
      childEvents[evt] = statePrefix ? `${statePrefix}.${handler}` : handler;
    }

    // Pre-render children (default slot)
    const preRenderedSlot: Bindings = { htmlBody: "", bindings: [], attrBindings: [], eventBindings: [], inputBindings: [] };

    // Handle inline text as first child of slot
    if (node.text != null && node.text.trim() !== "") {
      const txtNode: HJXNode = { kind: "node", tag: "text", classes: [], attrs: {}, text: node.text, events: {}, bind: null, children: [] };
      const res = renderNode(txtNode, scope, imports, statePrefix, {}, {}, receivedSlots, ctx);
      preRenderedSlot.htmlBody += res.htmlBody;
      preRenderedSlot.bindings.push(...res.bindings);
      preRenderedSlot.attrBindings.push(...res.attrBindings);
      preRenderedSlot.eventBindings.push(...res.eventBindings);
      preRenderedSlot.inputBindings.push(...res.inputBindings);
    }

    if (node.children && node.children.length > 0) {
      for (const child of node.children) {
        const res = renderNode(child, scope, imports, statePrefix, {}, {}, receivedSlots, ctx);
        preRenderedSlot.htmlBody += res.htmlBody;
        preRenderedSlot.bindings.push(...res.bindings);
        preRenderedSlot.attrBindings.push(...res.attrBindings);
        preRenderedSlot.eventBindings.push(...res.eventBindings);
        preRenderedSlot.inputBindings.push(...res.inputBindings);
      }
    }

    const slotsMap = { "default": preRenderedSlot };
    const childResult = renderComponent(childComp, childPrefix, childProps, childEvents, slotsMap, { autoId: 0 });

    return childResult;
  }

  // Normal node: consumes an ID
  ctx.autoId++;

  function ensureDataId(n: HJXNode): string {
    return `${scope}-${Math.random().toString(36).slice(2, 7)}`;
  }

  function render(n: HJXNode, isRoot: boolean): string {
    // Handle <slot> inside recursive render
    if (n.tag === "slot") {
      const slotName = n.attrs["name"] || "default";
      const slotData = receivedSlots[slotName];

      if (slotData && slotData.htmlBody) {
        bindings.push(...slotData.bindings);
        attrBindings.push(...slotData.attrBindings);
        eventBindings.push(...slotData.eventBindings);
        inputBindings.push(...slotData.inputBindings);
        return slotData.htmlBody;
      }
      if (n.children) {
        return n.children.map(c => render(c, false)).join("");
      }
      return "";
    }

    // Component as child
    if (imports[n.tag]) {
      const childComp = imports[n.tag];
      const instanceId = ctx.autoId++;
      const childKey = `${n.tag}_${instanceId}`;
      const childPrefix = statePrefix ? `${statePrefix}.${childKey}` : childKey;

      const childProps: Record<string, string> = {};
      for (const [k, v] of Object.entries(n.attrs)) {
        if (v.includes("{{")) {
          childProps[k] = v.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, key) => {
            if (extraAttrs[key]) return extraAttrs[key];
            return `{{${statePrefix ? statePrefix + "." + key : key}}}`;
          });
        } else {
          childProps[k] = v;
        }
      }

      const childEvents: Record<string, string> = {};
      for (const [evt, handler] of Object.entries(n.events ?? {})) {
        childEvents[evt] = statePrefix ? `${statePrefix}.${handler}` : handler;
      }

      const preRenderedSlot: Bindings = { htmlBody: "", bindings: [], attrBindings: [], eventBindings: [], inputBindings: [] };
      if (n.text != null && n.text.trim() !== "") {
        const txtNode: HJXNode = { kind: "node", tag: "text", classes: [], attrs: {}, text: n.text, events: {}, bind: null, children: [] };
        const res = renderNode(txtNode, scope, imports, statePrefix, {}, {}, receivedSlots, ctx);
        preRenderedSlot.htmlBody += res.htmlBody;
        preRenderedSlot.bindings.push(...res.bindings);
        preRenderedSlot.attrBindings.push(...res.attrBindings);
        preRenderedSlot.eventBindings.push(...res.eventBindings);
        preRenderedSlot.inputBindings.push(...res.inputBindings);
      }
      if (n.children) {
        for (const child of n.children) {
          const res = renderNode(child, scope, imports, statePrefix, {}, {}, receivedSlots, ctx);
          preRenderedSlot.htmlBody += res.htmlBody;
          preRenderedSlot.bindings.push(...res.bindings);
          preRenderedSlot.attrBindings.push(...res.attrBindings);
          preRenderedSlot.eventBindings.push(...res.eventBindings);
          preRenderedSlot.inputBindings.push(...res.inputBindings);
        }
      }

      const slotsMap = { "default": preRenderedSlot };
      const childRes = renderComponent(childComp, childPrefix, childProps, childEvents, slotsMap, { autoId: 0 });

      bindings.push(...childRes.bindings);
      attrBindings.push(...childRes.attrBindings);
      eventBindings.push(...childRes.eventBindings);
      inputBindings.push(...childRes.inputBindings);

      return childRes.htmlBody;
    }

    // Normal node
    ctx.autoId++;

    const tag = mapTag(n.tag);
    const dataId = ensureDataId(n);
    const attrParts: string[] = [];
    attrParts.push(`data-hjx-id="${dataId}"`);
    attrParts.push(`data-hjx-scope="${scope}"`);

    if (n.id) attrParts.push(`id="${escapeAttr(n.id)}"`);

    const classes = new Set(n.classes);
    if (isRoot && extraAttrs["class"]) {
      extraAttrs["class"].split(" ").forEach(c => c && classes.add(c));
    }
    if (classes.size > 0) {
      attrParts.push(`class="${Array.from(classes).map(escapeAttr).join(" ")}"`);
    }

    const allAttrs = isRoot ? { ...n.attrs, ...extraAttrs } : n.attrs;

    for (const [key, val] of Object.entries(allAttrs)) {
      if (key === "data-hjx-id" || key === "data-hjx-scope") continue;
      // Allow class interpolation
      if (val.includes("{{")) {
        const finalTemplate = val.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, k) => {
          if (extraAttrs[k]) return extraAttrs[k];
          return `{{${statePrefix ? statePrefix + "." + k : k}}}`;
        });
        attrBindings.push({ selector: `[data-hjx-id="${dataId}"]`, attr: key, template: finalTemplate });
      } else {
        attrParts.push(`${key}="${escapeAttr(val)}"`);
      }
    }

    // events: merge node events and extraEvents if root
    const mergedEvents = { ...(n.events ?? {}), ...(isRoot ? extraEvents : {}) };
    for (const [evt, handler] of Object.entries(mergedEvents)) {
      if (evt === "click") {
        // If handler is already prefixed (from extraEvents), use as is. 
        // If it's from n.events, prefix it now.
        const fullHandler = (isRoot && extraEvents[evt] === handler) ? handler : (statePrefix ? `${statePrefix}.${handler}` : handler);
        eventBindings.push({ selector: `[data-hjx-id="${dataId}"]`, handler: fullHandler });
      }
    }

    if (n.bind?.prop === "value") {
      const fullState = statePrefix ? `${statePrefix}.${n.bind.state}` : n.bind.state;
      inputBindings.push({ selector: `[data-hjx-id="${dataId}"]`, stateKey: fullState });
    }

    if (n.text != null) {
      if (n.text.includes("{{")) {
        const rewrittenTemplate = n.text.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, key) => {
          if (extraAttrs[key]) return extraAttrs[key];
          return `{{${statePrefix ? statePrefix + "." + key : key}}}`;
        });
        bindings.push({ selector: `[data-hjx-id="${dataId}"]`, template: rewrittenTemplate });
      }
    }

    const inner = n.children?.length ? n.children.map(c => render(c, false)).join("") : (n.text != null ? escapeTextWithInterpolation(n.text) : "");

    return `<${tag} ${attrParts.join(" ")}>${inner}</${tag}>`;
  }

  const htmlBody = render(node, true);
  return { htmlBody, bindings, attrBindings, eventBindings, inputBindings };
}

function mapTag(tag: string): string {
  const t = tag.toLowerCase();
  if (t === "view") return "div";
  if (t === "text") return "span";
  if (t === "button") return "button";
  if (t === "input") return "input";
  return t;
}

function escapeAttr(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTextWithInterpolation(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function serverDrivenRuntimeJS(): string {
  return `
const runtimeCode = ${JSON.stringify(runtimeModuleSource())};
const blob = new Blob([runtimeCode], { type: "text/javascript" });
const runtimeUrl = URL.createObjectURL(blob);
window.__HJX_RUNTIME_URL__ = runtimeUrl;
`;
}

export function runtimeModuleSource(): string {
  return `// HJX runtime v0.1 (Server Driven)

export function createRemoteStore(wsUrl, initial) {
  const state = { ...initial };
  const listeners = new Set();

  let ws;

  function connect() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      console.log("Connected to server");
    };
    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        console.log("HJX Received:", data.type, data.payload || data.name);
        if (data.type === "state") {
          Object.assign(state, data.payload);
          notify();
        } else if (data.type === "patch") {
          applyPatch(state, data.payload);
          notify();
        }
      } catch (e) {
        console.error("WS error", e);
      }
    };
    ws.onclose = () => {
      console.log("Disconnected. Reconnecting...");
      setTimeout(connect, 1000);
    };
  }

  connect();

  function notify() {
    listeners.forEach(fn => fn());
  }

  return {
    get: () => state,
    set: (patch) => {
      applyPatch(state, patch);
      notify();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "state_update", payload: patch }));
      }
    },
    sendEvent: (handlerName) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "event", name: handlerName }));
      }
    },
    subscribe: (fn) => { listeners.add(fn); return () => listeners.delete(fn); }
  };
}

function applyPatch(state, patch) {
  console.log("HJX Applying patch:", patch);
  for (const [key, value] of Object.entries(patch)) {
    if (key.includes(".")) {
      const parts = key.split(".");
      let target = state;
      for (let i = 0; i < parts.length - 1; i++) {
        if (!target[parts[i]]) target[parts[i]] = {};
        target = target[parts[i]];
      }
      target[parts[parts.length - 1]] = value;
    } else {
      state[key] = value;
    }
  }
}

function getByPath(obj, path) {
  return path.split(".").reduce((acc, part) => acc && acc[part], obj);
}

export function textBinder(store, root, selector, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\\{\\{\\s*([A-Za-z_][A-Za-z0-9_.]*)\\s*\\}\\}/g, (_, key) => String(getByPath(s, key) ?? ""));
    el.textContent = out;
  };
  render();
  store.subscribe(render);
}

export function attrBinder(store, root, selector, attr, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\\{\\{\\s*([A-Za-z_][A-Za-z0-9_.]*)\\s*\\}\\}/g, (_, key) => String(getByPath(s, key) ?? ""));

    if (out === "false" || out === "null" || out === "undefined") {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, out);
    }

    if (attr === "value" && "value" in el) {
        el.value = out;
    }
  };
  render();
  store.subscribe(render);
}

export function clickBinder(store, root, selector, fn) {
  const el = root.querySelector(selector);
  if (!el) return;
  el.addEventListener("click", () => fn({ store }));
}

export function inputBinder(store, root, selector, stateKey) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const val = getByPath(s, stateKey);
    if (el.value !== String(val ?? "")) el.value = String(val ?? "");
  };
  render();
  store.subscribe(render);
  el.addEventListener("input", (e) => {
    const v = e.target.value;
    store.set({ [stateKey]: v });
  });
}

export function mount() {}
`;
}
