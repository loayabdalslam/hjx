import { HJXAst, HJXNode } from "../types.js";
import { LoadedComponent } from "../loader.js";
import { scopeCss } from "./vanilla_scope_css.js";

export function buildServerDriven(tree: LoadedComponent): { html: string; css: string; js: string } {
  const cssParts = new Map<string, string>();

  function collectCss(comp: LoadedComponent) {
    const scope = `hjx-${comp.ast.component.name.toLowerCase()}`;
    if (!cssParts.has(scope)) {
      cssParts.set(scope, scopeCss(comp.ast.style ?? "", scope));
    }
    for (const child of Object.values(comp.imports)) {
      collectCss(child);
    }
  }
  collectCss(tree);
  const css = Array.from(cssParts.values()).join("\n");

  const { htmlBody, bindings, eventBindings, inputBindings } = renderComponent(tree, "");

  // We don't compile handlers to JS here because they run on the server.
  // We just need the initial state structure for potential hydration,
  // though the server will send the authoritative state on connection.
  // Note: Flattened state is needed for hydration if we did that, but we rely on WS init.
  const initialState = "{}"; // Client starts empty, gets state from server

  const js = `// Generated by HJX v0.1 (server-driven)
import { createRemoteStore, textBinder, clickBinder, inputBinder } from "./runtime.js";

const initialState = ${initialState};

export function createApp(rootEl) {
  // Auto-connect to the server origin via WebSocket
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const wsUrl = protocol + "//" + location.host + "/hjx";

  const store = createRemoteStore(wsUrl, initialState);

  // bind text interpolations
  ${bindings.map((b) => `textBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind clicks
  // Instead of executing a local handler, we send an event to the server
  ${eventBindings.map((e) => `clickBinder(store, rootEl, ${JSON.stringify(e.selector)}, () => store.sendEvent(${JSON.stringify(e.handler)}));`).join("\n  ")}

  // bind inputs (2-way)
  ${inputBindings.map((b) => `inputBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.stateKey)});`).join("\n  ")}

  return { store };
}

export function mountApp() {
  const root = document.getElementById("app");
  if (!root) throw new Error("Missing #app");
  // root scope is main component
  root.setAttribute("data-hjx-scope", ${JSON.stringify(`hjx-${tree.ast.component.name.toLowerCase()}`)});
  root.innerHTML = ${JSON.stringify(htmlBody)};
  createApp(root);
}

mountApp();
`;

  // We need a modified runtime that supports RemoteStore
  const runtime = serverDrivenRuntimeJS();

  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${escapeHtml(tree.ast.component.name)}</title>
  <link rel="stylesheet" href="./app.css"/>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    // Inline runtime module
    ${runtime}
  </script>
  <script type="module" src="./app.js"></script>
</body>
</html>
`;

  return { html, css, js: js + "\n\n// NOTE: also emit runtime.js in output.\n" };
}

function escapeHtml(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function emptyRoot(): HJXNode {
  return { kind: "node", tag: "view", id: "root", classes: [], attrs: {}, text: null, events: {}, bind: null, children: [
    { kind: "node", tag: "text", classes: [], attrs: {}, text: "Empty layout", events: {}, bind: null, children: [] }
  ]};
}

type Bindings = {
  htmlBody: string;
  bindings: Array<{ selector: string; template: string }>;
  eventBindings: Array<{ selector: string; handler: string }>;
  inputBindings: Array<{ selector: string; stateKey: string }>;
};

function renderComponent(comp: LoadedComponent, statePrefix: string): Bindings {
  const scope = `hjx-${comp.ast.component.name.toLowerCase()}`;
  return renderNode(comp.ast.layout ?? emptyRoot(), scope, comp.imports, statePrefix);
}

// Reuse renderNode logic from vanilla, or duplicate it to avoid circular deps if refactoring is hard.
// Since vanilla.ts is not exporting renderNode, I will duplicate it for now or refactor.
// For simplicity in this task, I'll duplicate the render logic. It's small.

function renderNode(
  node: HJXNode,
  scope: string,
  imports: Record<string, LoadedComponent>,
  statePrefix: string
): Bindings {
  const bindings: Array<{ selector: string; template: string }> = [];
  const eventBindings: Array<{ selector: string; handler: string }> = [];
  const inputBindings: Array<{ selector: string; stateKey: string }> = [];

  // Check if node tag is an imported component
  if (imports[node.tag]) {
    const childComp = imports[node.tag];
    const childPrefix = statePrefix ? `${statePrefix}.${node.tag}` : node.tag;
    const childResult = renderComponent(childComp, childPrefix);

    // We need to wrap the child HTML in a container that represents this node?
    // Or replace this node with the child's root?
    // In HJX layout, `Counter:` is a node.
    // If we replace it directly, attributes on `Counter` (like classes) might be lost if we don't merge.
    // For v0.1 let's assume `Counter:` simply injects the child layout.
    // BUT we should probably wrap it if it has ID/Classes?
    // Let's assume for now imports render their own root.
    // If the usage has classes `Counter.foo:`, we should apply `.foo` to the root of Counter?
    // That requires merging attributes.
    // Simplification: Wrap in a div if usage has attributes, otherwise direct inject.
    // Actually simpler: Treat `node` as a wrapper `div` (or `view`) containing the component.
    // But then we have extra divs.

    // Better approach for composition:
    // Render the child component's layout.
    // The `htmlBody` of child is returned.
    // We append it to this node's output? No, this node IS the component instance.

    // Let's go with: The node in layout is replaced by the component's HTML.
    // We assume the component root accepts attributes?
    // v0.1: Ignore attributes on the instance tag for now, just render the component.

    return childResult;
  }

  let autoId = 0;

  function ensureDataId(n: HJXNode): string {
    const existing = n.attrs["data-hjx-id"];
    if (existing) return existing;
    // We need a unique ID across the whole app.
    // Using Math.random or just global counter?
    // Since this is build time (or per-request build), we can use a global counter if we want strictly unique IDs.
    // But `autoId` is local to this `renderNode` call which is recursive... wait.
    // `renderNode` is called recursively. `autoId` is reset.
    // We need a globally unique ID generator passed down or singleton.
    // Let's use a random suffix to be safe.
    const id = `${scope}-${Math.random().toString(36).slice(2, 7)}`;
    n.attrs["data-hjx-id"] = id;
    return id;
  }

  function render(n: HJXNode): string {
    // If child is a component, handle it
    if (imports[n.tag]) {
      // Recurse for component
      const res = renderNode(n, scope, imports, statePrefix);
      bindings.push(...res.bindings);
      eventBindings.push(...res.eventBindings);
      inputBindings.push(...res.inputBindings);
      return res.htmlBody;
    }

    const tag = mapTag(n.tag);
    const dataId = ensureDataId(n);
    const attrParts: string[] = [];
    attrParts.push(`data-hjx-id="${dataId}"`);
    // Add scope for CSS
    attrParts.push(`data-hjx-scope="${scope}"`);

    if (n.id) attrParts.push(`id="${escapeAttr(n.id)}"`);
    if (n.classes?.length) attrParts.push(`class="${n.classes.map(escapeAttr).join(" ")}"`);

    // events
    for (const [evt, handler] of Object.entries(n.events ?? {})) {
      if (evt === "click") {
        // Prefix handler name: "inc" -> "Counter.inc"
        const fullHandler = statePrefix ? `${statePrefix}.${handler}` : handler;
        eventBindings.push({ selector: `[data-hjx-id="${dataId}"]`, handler: fullHandler });
      }
    }

    // input binding
    if (n.bind?.prop === "value") {
      const fullState = statePrefix ? `${statePrefix}.${n.bind.state}` : n.bind.state;
      inputBindings.push({ selector: `[data-hjx-id="${dataId}"]`, stateKey: fullState });
    }

    // text binding
    if (n.text != null) {
      if (n.text.includes("{{")) {
        // We need to rewrite interpolations: {{ count }} -> {{ Counter.count }}
        // The runtime textBinder will receive the TEMPLATE.
        // We update the template here.
        const rewrittenTemplate = n.text.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, key) => {
            return `{{${statePrefix ? statePrefix + "." + key : key}}}`;
        });
        bindings.push({ selector: `[data-hjx-id="${dataId}"]`, template: rewrittenTemplate });
      }
    }

    const inner = n.children?.length ? n.children.map(render).join("") : (n.text != null ? escapeTextWithInterpolation(n.text) : "");

    return `<${tag} ${attrParts.join(" ")}>${inner}</${tag}>`;
  }

  const htmlBody = render(node);
  return { htmlBody, bindings, eventBindings, inputBindings };
}

function mapTag(tag: string): string {
  const t = tag.toLowerCase();
  if (t === "view") return "div";
  if (t === "text") return "span";
  if (t === "button") return "button";
  if (t === "input") return "input";
  return t;
}

function escapeAttr(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTextWithInterpolation(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function serverDrivenRuntimeJS(): string {
  return `
const runtimeCode = ${JSON.stringify(runtimeModuleSource())};
const blob = new Blob([runtimeCode], { type: "text/javascript" });
const runtimeUrl = URL.createObjectURL(blob);
window.__HJX_RUNTIME_URL__ = runtimeUrl;
`;
}

export function runtimeModuleSource(): string {
  return `// HJX runtime v0.1 (Server Driven)

export function createRemoteStore(wsUrl, initial) {
  const state = { ...initial };
  const listeners = new Set();

  let ws;

  function connect() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      console.log("Connected to server");
    };
    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        if (data.type === "state") {
          // deep merge or replacement? For v0.1 state is sent fully on init?
          // Our server logic sends full state tree.
          Object.assign(state, data.payload);
          notify();
        } else if (data.type === "patch") {
          // Flattened patch support?
          // If patch has keys like "Counter.count", we need to handle nested assignment?
          // Or we just Object.assign and let the getters access it?
          // If state is { C1: { count: 0 } }, and patch is { "C1.count": 1 }, Object.assign won't work deep.
          // BUT ServerSession sends patched structure: { C1: { count: 1 } } ?
          // Let's check ServerSession.runHandler. It returns prefixed patch: { "C1.count": 1 }.
          // So the client receives flat keys with dots.

          // We need a helper to apply flat patch to nested state.
          applyPatch(state, data.payload);
          notify();
        }
      } catch (e) {
        console.error("WS error", e);
      }
    };
    ws.onclose = () => {
      console.log("Disconnected. Reconnecting...");
      setTimeout(connect, 1000);
    };
  }

  connect();

  function notify() {
    listeners.forEach(fn => fn());
  }

  return {
    get: () => state,
    set: (patch) => {
      // Optimistic update?
      applyPatch(state, patch);
      notify();
      // Send to server
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "state_update", payload: patch }));
      }
    },
    sendEvent: (handlerName) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "event", name: handlerName }));
      }
    },
    subscribe: (fn) => { listeners.add(fn); return () => listeners.delete(fn); }
  };
}

function applyPatch(state, patch) {
  for (const [key, value] of Object.entries(patch)) {
    if (key.includes(".")) {
      const parts = key.split(".");
      let target = state;
      for (let i = 0; i < parts.length - 1; i++) {
        if (!target[parts[i]]) target[parts[i]] = {};
        target = target[parts[i]];
      }
      target[parts[parts.length - 1]] = value;
    } else {
      state[key] = value;
    }
  }
}

// Access nested state by path "A.B.c"
function getByPath(obj, path) {
  return path.split(".").reduce((acc, part) => acc && acc[part], obj);
}

export function textBinder(store, root, selector, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    // Regex now supports dots in identifier
    const out = template.replace(/\\{\\{\\s*([A-Za-z_][A-Za-z0-9_.]*)\\s*\\}\\}/g, (_, key) => String(getByPath(s, key) ?? ""));
    el.textContent = out;
  };
  render();
  store.subscribe(render);
}

export function clickBinder(store, root, selector, fn) {
  const el = root.querySelector(selector);
  if (!el) return;
  el.addEventListener("click", () => fn({ store }));
}

export function inputBinder(store, root, selector, stateKey) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const val = getByPath(s, stateKey);
    if (el.value !== String(val ?? "")) el.value = String(val ?? "");
  };
  render();
  store.subscribe(render);
  el.addEventListener("input", (e) => {
    const v = e.target.value;
    store.set({ [stateKey]: v });
  });
}

export function mount() {}
`;
}
