import { HJXAst, HJXNode } from "../types.js";
import { LoadedComponent } from "../loader.js";
import { scopeCss } from "./vanilla_scope_css.js";

export function buildServerDriven(tree: LoadedComponent): { html: string; css: string; js: string } {
  const cssParts = new Map<string, string>();

  function collectCss(comp: LoadedComponent) {
    const scope = `hjx-${comp.ast.component.name.toLowerCase()}`;
    if (!cssParts.has(scope)) {
      cssParts.set(scope, scopeCss(comp.ast.style ?? "", scope));
    }
    for (const child of Object.values(comp.imports)) {
      collectCss(child);
    }
  }
  collectCss(tree);
  const css = Array.from(cssParts.values()).join("\n");

  const { htmlBody, bindings, attrBindings, eventBindings, inputBindings } = renderComponent(tree, "");

  // We don't compile handlers to JS here because they run on the server.
  // We just need the initial state structure for potential hydration,
  // though the server will send the authoritative state on connection.
  // Note: Flattened state is needed for hydration if we did that, but we rely on WS init.
  const initialState = "{}"; // Client starts empty, gets state from server

  const js = `// Generated by HJX v0.1 (server-driven)
import { createRemoteStore, textBinder, attrBinder, clickBinder, inputBinder } from "./runtime.js";

const initialState = ${initialState};

export function createApp(rootEl) {
  // Auto-connect to the server origin via WebSocket
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const wsUrl = protocol + "//" + location.host + "/hjx";

  const store = createRemoteStore(wsUrl, initialState);

  // bind text interpolations
  ${bindings.map((b) => `textBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind attributes
  ${attrBindings.map((b) => `attrBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.attr)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind clicks
  // Instead of executing a local handler, we send an event to the server
  ${eventBindings.map((e) => `clickBinder(store, rootEl, ${JSON.stringify(e.selector)}, () => store.sendEvent(${JSON.stringify(e.handler)}));`).join("\n  ")}

  // bind inputs (2-way)
  ${inputBindings.map((b) => `inputBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.stateKey)});`).join("\n  ")}

  return { store };
}

export function mountApp() {
  const root = document.getElementById("app");
  if (!root) throw new Error("Missing #app");
  // root scope is main component
  root.setAttribute("data-hjx-scope", ${JSON.stringify(`hjx-${tree.ast.component.name.toLowerCase()}`)});
  root.innerHTML = ${JSON.stringify(htmlBody)};
  createApp(root);
}

mountApp();
`;

  // We need a modified runtime that supports RemoteStore
  const runtime = serverDrivenRuntimeJS();

  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${escapeHtml(tree.ast.component.name)}</title>
  <link rel="stylesheet" href="./app.css"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            border: "hsl(var(--border))",
            input: "hsl(var(--input))",
            ring: "hsl(var(--ring))",
            background: "hsl(var(--background))",
            foreground: "hsl(var(--foreground))",
            primary: {
              DEFAULT: "hsl(var(--primary))",
              foreground: "hsl(var(--primary-foreground))",
            },
            secondary: {
              DEFAULT: "hsl(var(--secondary))",
              foreground: "hsl(var(--secondary-foreground))",
            },
            destructive: {
              DEFAULT: "hsl(var(--destructive))",
              foreground: "hsl(var(--destructive-foreground))",
            },
            muted: {
              DEFAULT: "hsl(var(--muted))",
              foreground: "hsl(var(--muted-foreground))",
            },
            accent: {
              DEFAULT: "hsl(var(--accent))",
              foreground: "hsl(var(--accent-foreground))",
            },
            popover: {
              DEFAULT: "hsl(var(--popover))",
              foreground: "hsl(var(--popover-foreground))",
            },
            card: {
              DEFAULT: "hsl(var(--card))",
              foreground: "hsl(var(--card-foreground))",
            },
          },
          borderRadius: {
            lg: "var(--radius)",
            md: "calc(var(--radius) - 2px)",
            sm: "calc(var(--radius) - 4px)",
          },
        },
      },
    }
  </script>
  <style>
    :root {
      --background: 0 0% 100%;
      --foreground: 222.2 84% 4.9%;
      --card: 0 0% 100%;
      --card-foreground: 222.2 84% 4.9%;
      --popover: 0 0% 100%;
      --popover-foreground: 222.2 84% 4.9%;
      --primary: 222.2 47.4% 11.2%;
      --primary-foreground: 210 40% 98%;
      --secondary: 210 40% 96.1%;
      --secondary-foreground: 222.2 47.4% 11.2%;
      --muted: 210 40% 96.1%;
      --muted-foreground: 215.4 16.3% 46.9%;
      --accent: 210 40% 96.1%;
      --accent-foreground: 222.2 47.4% 11.2%;
      --destructive: 0 84.2% 60.2%;
      --destructive-foreground: 210 40% 98%;
      --border: 214.3 31.8% 91.4%;
      --input: 214.3 31.8% 91.4%;
      --ring: 222.2 84% 4.9%;
      --radius: 0.5rem;
    }
    .dark {
      --background: 222.2 84% 4.9%;
      --foreground: 210 40% 98%;
      --card: 222.2 84% 4.9%;
      --card-foreground: 210 40% 98%;
      --popover: 222.2 84% 4.9%;
      --popover-foreground: 210 40% 98%;
      --primary: 210 40% 98%;
      --primary-foreground: 222.2 47.4% 11.2%;
      --secondary: 217.2 32.6% 17.5%;
      --secondary-foreground: 210 40% 98%;
      --muted: 217.2 32.6% 17.5%;
      --muted-foreground: 215 20.2% 65.1%;
      --accent: 217.2 32.6% 17.5%;
      --accent-foreground: 210 40% 98%;
      --destructive: 0 62.8% 30.6%;
      --destructive-foreground: 210 40% 98%;
      --border: 217.2 32.6% 17.5%;
      --input: 217.2 32.6% 17.5%;
      --ring: 212.7 26.8% 83.9%;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    // Inline runtime module
    ${runtime}
  </script>
  <script type="module" src="./app.js"></script>
</body>
</html>
`;

  return { html, css, js: js + "\n\n// NOTE: also emit runtime.js in output.\n" };
}

function escapeHtml(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function emptyRoot(): HJXNode {
  return { kind: "node", tag: "view", id: "root", classes: [], attrs: {}, text: null, events: {}, bind: null, children: [
    { kind: "node", tag: "text", classes: [], attrs: {}, text: "Empty layout", events: {}, bind: null, children: [] }
  ]};
}

type Bindings = {
  htmlBody: string;
  bindings: Array<{ selector: string; template: string }>;
  attrBindings: Array<{ selector: string; attr: string; template: string }>;
  eventBindings: Array<{ selector: string; handler: string }>;
  inputBindings: Array<{ selector: string; stateKey: string }>;
};

function renderComponent(comp: LoadedComponent, statePrefix: string, extraAttrs: Record<string, string> = {}): Bindings {
  const scope = `hjx-${comp.ast.component.name.toLowerCase()}`;
  return renderNode(comp.ast.layout ?? emptyRoot(), scope, comp.imports, statePrefix, extraAttrs);
}

function renderNode(
  node: HJXNode,
  scope: string,
  imports: Record<string, LoadedComponent>,
  statePrefix: string,
  extraAttrs: Record<string, string> = {}
): Bindings {
  const bindings: Array<{ selector: string; template: string }> = [];
  const attrBindings: Array<{ selector: string; attr: string; template: string }> = [];
  const eventBindings: Array<{ selector: string; handler: string }> = [];
  const inputBindings: Array<{ selector: string; stateKey: string }> = [];

  // Check if node tag is an imported component
  if (imports[node.tag]) {
    const childComp = imports[node.tag];
    const childPrefix = statePrefix ? `${statePrefix}.${node.tag}` : node.tag;
    // Merge attributes from usage into child component
    const childResult = renderComponent(childComp, childPrefix, { ...node.attrs, ...extraAttrs });
    return childResult;
  }

  let autoId = 0;

  function ensureDataId(n: HJXNode): string {
    const existing = n.attrs["data-hjx-id"];
    if (existing) return existing;
    const id = `${scope}-${Math.random().toString(36).slice(2, 7)}`;
    n.attrs["data-hjx-id"] = id;
    return id;
  }

  function render(n: HJXNode, isRoot: boolean): string {
    // If child is a component, handle it
    if (imports[n.tag]) {
      // Recurse for component
      const childComp = imports[n.tag];
      const childPrefix = statePrefix ? `${statePrefix}.${n.tag}` : n.tag;
      // We pass n.attrs (attributes on the usage) to the child.
      // Note: we do NOT pass extraAttrs recursively down to children of children unless they are the root of that child.
      // But here 'n' is inside the layout of the current component. 'extraAttrs' apply to the ROOT of the current component.
      // So for children inside the layout, we don't pass extraAttrs.
      const childRes = renderComponent(childComp, childPrefix, n.attrs);
      bindings.push(...childRes.bindings);
      attrBindings.push(...childRes.attrBindings);
      eventBindings.push(...childRes.eventBindings);
      inputBindings.push(...childRes.inputBindings);
      return childRes.htmlBody;
    }

    const tag = mapTag(n.tag);
    const dataId = ensureDataId(n);
    const attrParts: string[] = [];
    attrParts.push(`data-hjx-id="${dataId}"`);
    // Add scope for CSS
    attrParts.push(`data-hjx-scope="${scope}"`);

    if (n.id) attrParts.push(`id="${escapeAttr(n.id)}"`);

    // Handle classes: merge n.classes and extraAttrs.class (if root)
    const classes = new Set(n.classes);
    if (isRoot && extraAttrs["class"]) {
      extraAttrs["class"].split(" ").forEach(c => c && classes.add(c));
    }
    if (classes.size > 0) {
      attrParts.push(`class="${Array.from(classes).map(escapeAttr).join(" ")}"`);
    }

    // Merge attributes
    // If isRoot, merge extraAttrs.
    const allAttrs = isRoot ? { ...n.attrs, ...extraAttrs } : n.attrs;

    for (const [key, val] of Object.entries(allAttrs)) {
      if (key === "data-hjx-id" || key === "data-hjx-scope") continue;
      if (key === "class") continue; // handled above

      // check for interpolation {{ }}
      if (val.includes("{{")) {
        // dynamic attribute
        const rewrittenTemplate = val.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, k) => {
            return `{{${statePrefix ? statePrefix + "." + k : k}}}`;
        });
        attrBindings.push({ selector: `[data-hjx-id="${dataId}"]`, attr: key, template: rewrittenTemplate });
      } else {
        // static attribute
        attrParts.push(`${key}="${escapeAttr(val)}"`);
      }
    }

    // events
    for (const [evt, handler] of Object.entries(n.events ?? {})) {
      if (evt === "click") {
        // Prefix handler name: "inc" -> "Counter.inc"
        const fullHandler = statePrefix ? `${statePrefix}.${handler}` : handler;
        eventBindings.push({ selector: `[data-hjx-id="${dataId}"]`, handler: fullHandler });
      }
    }

    // input binding
    if (n.bind?.prop === "value") {
      const fullState = statePrefix ? `${statePrefix}.${n.bind.state}` : n.bind.state;
      inputBindings.push({ selector: `[data-hjx-id="${dataId}"]`, stateKey: fullState });
    }

    // text binding
    if (n.text != null) {
      if (n.text.includes("{{")) {
        // We need to rewrite interpolations: {{ count }} -> {{ Counter.count }}
        // The runtime textBinder will receive the TEMPLATE.
        // We update the template here.
        const rewrittenTemplate = n.text.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_.]*)\s*\}\}/g, (_, key) => {
            return `{{${statePrefix ? statePrefix + "." + key : key}}}`;
        });
        bindings.push({ selector: `[data-hjx-id="${dataId}"]`, template: rewrittenTemplate });
      }
    }

    const inner = n.children?.length ? n.children.map(c => render(c, false)).join("") : (n.text != null ? escapeTextWithInterpolation(n.text) : "");

    return `<${tag} ${attrParts.join(" ")}>${inner}</${tag}>`;
  }

  const htmlBody = render(node, true);
  return { htmlBody, bindings, attrBindings, eventBindings, inputBindings };
}

function mapTag(tag: string): string {
  const t = tag.toLowerCase();
  if (t === "view") return "div";
  if (t === "text") return "span";
  if (t === "button") return "button";
  if (t === "input") return "input";
  return t;
}

function escapeAttr(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTextWithInterpolation(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function serverDrivenRuntimeJS(): string {
  return `
const runtimeCode = ${JSON.stringify(runtimeModuleSource())};
const blob = new Blob([runtimeCode], { type: "text/javascript" });
const runtimeUrl = URL.createObjectURL(blob);
window.__HJX_RUNTIME_URL__ = runtimeUrl;
`;
}

export function runtimeModuleSource(): string {
  return `// HJX runtime v0.1 (Server Driven)

export function createRemoteStore(wsUrl, initial) {
  const state = { ...initial };
  const listeners = new Set();

  let ws;

  function connect() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      console.log("Connected to server");
    };
    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        if (data.type === "state") {
          Object.assign(state, data.payload);
          notify();
        } else if (data.type === "patch") {
          applyPatch(state, data.payload);
          notify();
        }
      } catch (e) {
        console.error("WS error", e);
      }
    };
    ws.onclose = () => {
      console.log("Disconnected. Reconnecting...");
      setTimeout(connect, 1000);
    };
  }

  connect();

  function notify() {
    listeners.forEach(fn => fn());
  }

  return {
    get: () => state,
    set: (patch) => {
      applyPatch(state, patch);
      notify();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "state_update", payload: patch }));
      }
    },
    sendEvent: (handlerName) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "event", name: handlerName }));
      }
    },
    subscribe: (fn) => { listeners.add(fn); return () => listeners.delete(fn); }
  };
}

function applyPatch(state, patch) {
  for (const [key, value] of Object.entries(patch)) {
    if (key.includes(".")) {
      const parts = key.split(".");
      let target = state;
      for (let i = 0; i < parts.length - 1; i++) {
        if (!target[parts[i]]) target[parts[i]] = {};
        target = target[parts[i]];
      }
      target[parts[parts.length - 1]] = value;
    } else {
      state[key] = value;
    }
  }
}

function getByPath(obj, path) {
  return path.split(".").reduce((acc, part) => acc && acc[part], obj);
}

export function textBinder(store, root, selector, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\\{\\{\\s*([A-Za-z_][A-Za-z0-9_.]*)\\s*\\}\\}/g, (_, key) => String(getByPath(s, key) ?? ""));
    el.textContent = out;
  };
  render();
  store.subscribe(render);
}

export function attrBinder(store, root, selector, attr, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\\{\\{\\s*([A-Za-z_][A-Za-z0-9_.]*)\\s*\\}\\}/g, (_, key) => String(getByPath(s, key) ?? ""));

    if (out === "false" || out === "null" || out === "undefined") {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, out);
    }

    if (attr === "value" && "value" in el) {
        el.value = out;
    }
  };
  render();
  store.subscribe(render);
}

export function clickBinder(store, root, selector, fn) {
  const el = root.querySelector(selector);
  if (!el) return;
  el.addEventListener("click", () => fn({ store }));
}

export function inputBinder(store, root, selector, stateKey) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const val = getByPath(s, stateKey);
    if (el.value !== String(val ?? "")) el.value = String(val ?? "");
  };
  render();
  store.subscribe(render);
  el.addEventListener("input", (e) => {
    const v = e.target.value;
    store.set({ [stateKey]: v });
  });
}

export function mount() {}
`;
}
