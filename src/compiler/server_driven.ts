import { HJXAst, HJXNode } from "../types.js";
import { scopeCss } from "./vanilla_scope_css.js";

export function buildServerDriven(ast: HJXAst): { html: string; css: string; js: string } {
  const scope = `hjx-${ast.component.name.toLowerCase()}`;
  const css = scopeCss(ast.style ?? "", scope);

  const { htmlBody, bindings, eventBindings, inputBindings } = renderNode(ast.layout ?? emptyRoot(), scope);

  // We don't compile handlers to JS here because they run on the server.
  // We just need the initial state structure for potential hydration,
  // though the server will send the authoritative state on connection.
  const initialState = JSON.stringify(ast.state);

  const js = `// Generated by HJX v0.1 (server-driven)
import { createRemoteStore, textBinder, clickBinder, inputBinder } from "./runtime.js";

const SCOPE = ${JSON.stringify(scope)};
const initialState = ${initialState};

export function createApp(rootEl) {
  // Auto-connect to the server origin via WebSocket
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const wsUrl = protocol + "//" + location.host + "/hjx";

  const store = createRemoteStore(wsUrl, initialState);

  // bind text interpolations
  ${bindings.map((b) => `textBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind clicks
  // Instead of executing a local handler, we send an event to the server
  ${eventBindings.map((e) => `clickBinder(store, rootEl, ${JSON.stringify(e.selector)}, () => store.sendEvent(${JSON.stringify(e.handler)}));`).join("\n  ")}

  // bind inputs (2-way)
  ${inputBindings.map((b) => `inputBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.stateKey)});`).join("\n  ")}

  return { store };
}

export function mountApp() {
  const root = document.getElementById("app");
  if (!root) throw new Error("Missing #app");
  root.setAttribute("data-hjx-scope", SCOPE);
  root.innerHTML = ${JSON.stringify(htmlBody)};
  createApp(root);
}

mountApp();
`;

  // We need a modified runtime that supports RemoteStore
  const runtime = serverDrivenRuntimeJS();

  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${escapeHtml(ast.component.name)}</title>
  <link rel="stylesheet" href="./app.css"/>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    // Inline runtime module
    ${runtime}
  </script>
  <script type="module" src="./app.js"></script>
</body>
</html>
`;

  return { html, css, js: js + "\n\n// NOTE: also emit runtime.js in output.\n" };
}

function escapeHtml(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function emptyRoot(): HJXNode {
  return { kind: "node", tag: "view", id: "root", classes: [], attrs: {}, text: null, events: {}, bind: null, children: [
    { kind: "node", tag: "text", classes: [], attrs: {}, text: "Empty layout", events: {}, bind: null, children: [] }
  ]};
}

// Reuse renderNode logic from vanilla, or duplicate it to avoid circular deps if refactoring is hard.
// Since vanilla.ts is not exporting renderNode, I will duplicate it for now or refactor.
// For simplicity in this task, I'll duplicate the render logic. It's small.

function renderNode(node: HJXNode, scope: string): {
  htmlBody: string;
  bindings: Array<{ selector: string; template: string }>;
  eventBindings: Array<{ selector: string; handler: string }>;
  inputBindings: Array<{ selector: string; stateKey: string }>;
} {
  const bindings: Array<{ selector: string; template: string }> = [];
  const eventBindings: Array<{ selector: string; handler: string }> = [];
  const inputBindings: Array<{ selector: string; stateKey: string }> = [];

  let autoId = 0;

  function ensureDataId(n: HJXNode): string {
    const existing = n.attrs["data-hjx-id"];
    if (existing) return existing;
    const id = `${scope}-${autoId++}`;
    n.attrs["data-hjx-id"] = id;
    return id;
  }

  function render(n: HJXNode): string {
    const tag = mapTag(n.tag);
    const dataId = ensureDataId(n);
    const attrParts: string[] = [];
    attrParts.push(`data-hjx-id="${dataId}"`);

    if (n.id) attrParts.push(`id="${escapeAttr(n.id)}"`);
    if (n.classes?.length) attrParts.push(`class="${n.classes.map(escapeAttr).join(" ")}"`);

    // events
    for (const [evt, handler] of Object.entries(n.events ?? {})) {
      if (evt === "click") {
        eventBindings.push({ selector: `[data-hjx-id="${dataId}"]`, handler });
      }
    }

    // input binding
    if (n.bind?.prop === "value") {
      inputBindings.push({ selector: `[data-hjx-id="${dataId}"]`, stateKey: n.bind.state });
    }

    // text binding
    if (n.text != null) {
      if (n.text.includes("{{")) {
        bindings.push({ selector: `[data-hjx-id="${dataId}"]`, template: n.text });
      }
    }

    const inner = n.children?.length ? n.children.map(render).join("") : (n.text != null ? escapeTextWithInterpolation(n.text) : "");

    return `<${tag} ${attrParts.join(" ")}>${inner}</${tag}>`;
  }

  const htmlBody = render(node);
  return { htmlBody, bindings, eventBindings, inputBindings };
}

function mapTag(tag: string): string {
  const t = tag.toLowerCase();
  if (t === "view") return "div";
  if (t === "text") return "span";
  if (t === "button") return "button";
  if (t === "input") return "input";
  return t;
}

function escapeAttr(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTextWithInterpolation(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function serverDrivenRuntimeJS(): string {
  return `
const runtimeCode = ${JSON.stringify(runtimeModuleSource())};
const blob = new Blob([runtimeCode], { type: "text/javascript" });
const runtimeUrl = URL.createObjectURL(blob);
window.__HJX_RUNTIME_URL__ = runtimeUrl;
`;
}

export function runtimeModuleSource(): string {
  return `// HJX runtime v0.1 (Server Driven)

export function createRemoteStore(wsUrl, initial) {
  const state = { ...initial };
  const listeners = new Set();

  let ws;

  function connect() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      console.log("Connected to server");
    };
    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        if (data.type === "state") {
          Object.assign(state, data.payload);
          notify();
        } else if (data.type === "patch") {
          Object.assign(state, data.payload);
          notify();
        }
      } catch (e) {
        console.error("WS error", e);
      }
    };
    ws.onclose = () => {
      console.log("Disconnected. Reconnecting...");
      setTimeout(connect, 1000);
    };
  }

  connect();

  function notify() {
    listeners.forEach(fn => fn());
  }

  return {
    get: () => state,
    set: (patch) => {
      // Optimistic update?
      Object.assign(state, patch);
      notify();
      // Send to server
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "state_update", payload: patch }));
      }
    },
    sendEvent: (handlerName) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "event", name: handlerName }));
      }
    },
    subscribe: (fn) => { listeners.add(fn); return () => listeners.delete(fn); }
  };
}

export function textBinder(store, root, selector, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\\{\\{\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\}\\}/g, (_, key) => String(s[key] ?? ""));
    el.textContent = out;
  };
  render();
  store.subscribe(render);
}

export function clickBinder(store, root, selector, fn) {
  const el = root.querySelector(selector);
  if (!el) return;
  // fn is passed (ctx), but in server driven we usually passed just () => store.sendEvent(...)
  el.addEventListener("click", () => fn({ store }));
}

export function inputBinder(store, root, selector, stateKey) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    if (el.value !== String(s[stateKey] ?? "")) el.value = String(s[stateKey] ?? "");
  };
  render();
  store.subscribe(render);
  el.addEventListener("input", (e) => {
    const v = e.target.value;
    store.set({ [stateKey]: v });
  });
}

export function mount() {}
`;
}
