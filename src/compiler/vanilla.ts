import { HJXAst, HJXNode } from "../types.js";
import { compileHandlersToJS } from "./vanilla_handlers.js";
import { scopeCss } from "./vanilla_scope_css.js";

export function buildVanilla(ast: HJXAst): { html: string; css: string; js: string } {
  const scope = `hjx-${ast.component.name.toLowerCase()}`;
  const css = scopeCss(ast.style ?? "", scope);

  const { htmlBody, bindings, eventBindings, inputBindings } = renderNode(ast.layout ?? emptyRoot(), scope);

  const handlersJS = compileHandlersToJS(ast.handlers, Object.keys(ast.state));
  const initialState = JSON.stringify(ast.state);

  const js = `// Generated by HJX v0.1 (vanilla)
import { createStore, mount, textBinder, clickBinder, inputBinder } from "./runtime.js";

const SCOPE = ${JSON.stringify(scope)};
const initialState = ${initialState};

export function createApp(rootEl) {
  const store = createStore(initialState);

  // bind text interpolations
  ${bindings.map((b, idx) => `textBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind clicks
  ${eventBindings.map((e) => `clickBinder(store, rootEl, ${JSON.stringify(e.selector)}, (ctx) => handlers[${JSON.stringify(e.handler)}](ctx));`).join("\n  ")}

  // bind inputs (2-way)
  ${inputBindings.map((b) => `inputBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.stateKey)});`).join("\n  ")}

  const handlers = ${handlersJS};

  return { store, handlers };
}

export function mountApp() {
  const root = document.getElementById("app");
  if (!root) throw new Error("Missing #app");
  root.setAttribute("data-hjx-scope", SCOPE);
  root.innerHTML = ${JSON.stringify(htmlBody)};
  createApp(root);
}

mountApp();
`;

  const runtime = vanillaRuntimeJS();

  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${escapeHtml(ast.component.name)}</title>
  <link rel="stylesheet" href="./app.css"/>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    // Inline runtime module (no bundler required)
    ${runtime}
  </script>
  <script type="module" src="./app.js"></script>
</body>
</html>
`;

  // app.js expects runtime.js via relative import; we inline runtime in HTML and also emit runtime.js for completeness.
  // In dev server, the inline runtime already exists; but keeping runtime.js allows easy extraction later.
  // We'll emit runtime.js by embedding it into js via dynamic module if needed. Simpler: write a runtime.js file as well in dev/build.
  // Here we return js expecting runtime.js, and the caller writes runtime.js too.
  return { html, css, js: js + "\n\n// NOTE: also emit runtime.js in output.\n" };
}

function escapeHtml(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function emptyRoot(): HJXNode {
  return { kind: "node", tag: "view", id: "root", classes: [], attrs: {}, text: null, events: {}, bind: null, children: [
    { kind: "node", tag: "text", classes: [], attrs: {}, text: "Empty layout", events: {}, bind: null, children: [] }
  ]};
}

function renderNode(node: HJXNode, scope: string): {
  htmlBody: string;
  bindings: Array<{ selector: string; template: string }>;
  eventBindings: Array<{ selector: string; handler: string }>;
  inputBindings: Array<{ selector: string; stateKey: string }>;
} {
  const bindings: Array<{ selector: string; template: string }> = [];
  const eventBindings: Array<{ selector: string; handler: string }> = [];
  const inputBindings: Array<{ selector: string; stateKey: string }> = [];

  let autoId = 0;

  function ensureDataId(n: HJXNode): string {
    const existing = n.attrs["data-hjx-id"];
    if (existing) return existing;
    const id = `${scope}-${autoId++}`;
    n.attrs["data-hjx-id"] = id;
    return id;
  }

  function render(n: HJXNode): string {
    const tag = mapTag(n.tag);
    const dataId = ensureDataId(n);
    const attrParts: string[] = [];
    attrParts.push(`data-hjx-id="${dataId}"`);

    if (n.id) attrParts.push(`id="${escapeAttr(n.id)}"`);
    if (n.classes?.length) attrParts.push(`class="${n.classes.map(escapeAttr).join(" ")}"`);

    // events
    for (const [evt, handler] of Object.entries(n.events ?? {})) {
      if (evt === "click") {
        // binder uses data-hjx-id selector
        eventBindings.push({ selector: `[data-hjx-id="${dataId}"]`, handler });
      }
    }

    // input binding
    if (n.bind?.prop === "value") {
      inputBindings.push({ selector: `[data-hjx-id="${dataId}"]`, stateKey: n.bind.state });
    }

    // text binding in leaf text-like nodes
    if (n.text != null) {
      // support interpolation {{x}}
      if (n.text.includes("{{")) {
        bindings.push({ selector: `[data-hjx-id="${dataId}"]`, template: n.text });
      }
    }

    // element text content
    const inner = n.children?.length ? n.children.map(render).join("") : (n.text != null ? escapeTextWithInterpolation(n.text) : "");

    return `<${tag} ${attrParts.join(" ")}>${inner}</${tag}>`;
  }

  const htmlBody = render(node);
  return { htmlBody, bindings, eventBindings, inputBindings };
}

function mapTag(tag: string): string {
  // limited set; allow raw html tags too
  const t = tag.toLowerCase();
  if (t === "view") return "div";
  if (t === "text") return "span";
  if (t === "button") return "button";
  if (t === "input") return "input";
  return t;
}

function escapeAttr(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTextWithInterpolation(s: string): string {
  // placeholders will be replaced by binder; keep as raw marker in text node
  // But we must escape HTML special chars.
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function vanillaRuntimeJS(): string {
  // runtime module exposed as ./runtime.js via blob URL in HTML
  // We'll create a module named runtime.js by injecting it into import map via dynamic module. For MVP simplicity:
  // We'll register a global object and app.js imports from "./runtime.js" will fail without bundler.
  // So we embed a tiny ES module loader shim that defines runtime as a module at runtime.
  // The devserver/build will also emit runtime.js file. This inline is just for the case you open index.html alone.
  return `
const runtimeCode = ${JSON.stringify(runtimeModuleSource())};
const blob = new Blob([runtimeCode], { type: "text/javascript" });
const runtimeUrl = URL.createObjectURL(blob);
window.__HJX_RUNTIME_URL__ = runtimeUrl;
`;
}

function runtimeModuleSource(): string {
  return `// HJX runtime v0.1
export function createStore(initial) {
  const state = { ...initial };
  const listeners = new Set();
  return {
    get: () => state,
    set: (patch) => { Object.assign(state, patch); listeners.forEach(fn => fn()); },
    subscribe: (fn) => { listeners.add(fn); return () => listeners.delete(fn); }
  };
}

export function textBinder(store, root, selector, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_]*)\s*\}\}/g, (_, key) => String(s[key] ?? ""));
    el.textContent = out;
  };
  render();
  store.subscribe(render);
}

export function clickBinder(store, root, selector, fn) {
  const el = root.querySelector(selector);
  if (!el) return;
  el.addEventListener("click", () => fn({ store }));
}

export function inputBinder(store, root, selector, stateKey) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    if (el.value !== String(s[stateKey] ?? "")) el.value = String(s[stateKey] ?? "");
  };
  render();
  store.subscribe(render);
  el.addEventListener("input", (e) => {
    const v = e.target.value;
    store.set({ [stateKey]: v });
  });
}

// mount is kept for future
export function mount() {}
`;
}
