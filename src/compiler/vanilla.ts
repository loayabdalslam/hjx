import { HJXAst, HJXNode } from "../types.js";
import { compileHandlersToJS } from "./vanilla_handlers.js";
import { scopeCss } from "./vanilla_scope_css.js";

export function buildVanilla(ast: HJXAst): { html: string; css: string; js: string } {
  const scope = `hjx-${ast.component.name.toLowerCase()}`;
  const css = scopeCss(ast.style ?? "", scope);

  const { htmlBody, bindings, eventBindings, inputBindings, ifForBindings } = renderNode(ast.layout ?? emptyRoot(), scope);

  const handlersJS = compileHandlersToJS(ast.handlers, Object.keys(ast.state));
  const initialState = JSON.stringify(ast.state);

  const js = `// Generated by HJX v0.1 (vanilla)
import { createStore, mount, textBinder, clickBinder, inputBinder, ifBinder, forBinder } from "./runtime.js";

const SCOPE = ${JSON.stringify(scope)};
const initialState = ${initialState};

export function createApp(rootEl) {
  const store = createStore(initialState);

  // bind text interpolations
  ${bindings.map((b, idx) => `textBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.template)});`).join("\n  ")}

  // bind clicks
  ${eventBindings.map((e) => `clickBinder(store, rootEl, ${JSON.stringify(e.selector)}, (ctx) => handlers[${JSON.stringify(e.handler)}](ctx));`).join("\n  ")}

  // bind inputs (2-way)
  ${inputBindings.map((b) => `inputBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.stateKey)});`).join("\n  ")}

  // bind if/for blocks
  ${ifForBindings.map((b) => {
    if (b.type === "if") {
      return `ifBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.condition)});`;
    } else {
      return `forBinder(store, rootEl, ${JSON.stringify(b.selector)}, ${JSON.stringify(b.item)}, ${JSON.stringify(b.list)});`;
    }
  }).join("\n  ")}

  const handlers = ${handlersJS};

  return { store, handlers };
}

export function mountApp() {
  const root = document.getElementById("app");
  if (!root) throw new Error("Missing #app");
  root.setAttribute("data-hjx-scope", SCOPE);
  root.innerHTML = ${JSON.stringify(htmlBody)};
  createApp(root);
}

mountApp();
`;

  const runtime = vanillaRuntimeJS();

  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>${escapeHtml(ast.component.name)}</title>
  <link rel="stylesheet" href="./app.css"/>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    // Inline runtime module (no bundler required)
    ${runtime}
  </script>
  <script type="module" src="./app.js"></script>
</body>
</html>
`;

  // app.js expects runtime.js via relative import; we inline runtime in HTML and also emit runtime.js for completeness.
  // In dev server, the inline runtime already exists; but keeping runtime.js allows easy extraction later.
  // We'll emit runtime.js by embedding it into js via dynamic module if needed. Simpler: write a runtime.js file as well in dev/build.
  // Here we return js expecting runtime.js, and the caller writes runtime.js too.
  return { html, css, js: js + "\n\n// NOTE: also emit runtime.js in output.\n" };
}

function escapeHtml(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function emptyRoot(): HJXNode {
  return { kind: "node", tag: "view", id: "root", classes: [], attrs: {}, text: null, events: {}, bind: null, children: [
    { kind: "node", tag: "text", classes: [], attrs: {}, text: "Empty layout", events: {}, bind: null, children: [] }
  ]};
}

function renderNode(node: HJXNode, scope: string): {
  htmlBody: string;
  bindings: Array<{ selector: string; template: string }>;
  eventBindings: Array<{ selector: string; handler: string }>;
  inputBindings: Array<{ selector: string; stateKey: string }>;
  ifForBindings: Array<{ selector: string; type: "if" | "for"; condition?: string; item?: string; list?: string }>;
} {
  const bindings: Array<{ selector: string; template: string }> = [];
  const eventBindings: Array<{ selector: string; handler: string }> = [];
  const inputBindings: Array<{ selector: string; stateKey: string }> = [];
  const ifForBindings: Array<{ selector: string; type: "if" | "for"; condition?: string; item?: string; list?: string }> = [];

  let autoId = 0;

  function ensureDataId(n: HJXNode): string {
    const existing = n.attrs["data-hjx-id"];
    if (existing) return existing;
    const id = `${scope}-${autoId++}`;
    n.attrs["data-hjx-id"] = id;
    return id;
  }

  function render(n: HJXNode): string {
    // Handle control flow
    if (n.kind === "if") {
      const condition = n.condition || "";
      const ifId = `${scope}-if-${autoId++}`;
      const childrenHtml = n.children?.map(render).join("") || "";
      ifForBindings.push({ selector: `[data-hjx-if="${ifId}"]`, type: "if", condition });
      return `<div data-hjx-if="${ifId}" style="display:none">${childrenHtml}</div>`;
    }

    if (n.kind === "for") {
      const iterator = n.iterator || { item: "item", list: "items" };
      const forId = `${scope}-for-${autoId++}`;
      // For blocks render as templates; actual rendering happens in runtime
      const childrenHtml = n.children?.map(render).join("") || "";
      ifForBindings.push({ selector: `[data-hjx-for="${forId}"]`, type: "for", item: iterator.item, list: iterator.list });
      return `<div data-hjx-for="${forId}" style="display:contents"><template>${childrenHtml}</template></div>`;
    }

    if (n.kind === "else") {
      // else is handled by parent if block; skip here
      return "";
    }

    const tag = mapTag(n.tag);
    const dataId = ensureDataId(n);
    const attrParts: string[] = [];
    attrParts.push(`data-hjx-id="${dataId}"`);

    if (n.id) attrParts.push(`id="${escapeAttr(n.id)}"`);
    if (n.classes?.length) attrParts.push(`class="${n.classes.map(escapeAttr).join(" ")}"`);

    // events
    for (const [evt, handler] of Object.entries(n.events ?? {})) {
      if (evt === "click") {
        // binder uses data-hjx-id selector
        eventBindings.push({ selector: `[data-hjx-id="${dataId}"]`, handler });
        // also emit attribute so dynamic templates can rebind
        attrParts.push(`data-hjx-click="${escapeAttr(handler)}"`);
      }
    }

    // input binding
    if (n.bind?.prop === "value") {
      inputBindings.push({ selector: `[data-hjx-id="${dataId}"]`, stateKey: n.bind.state });
    }

    // text binding in leaf text-like nodes
    if (n.text != null) {
      // support interpolation {{x}}
      if (n.text.includes("{{")) {
        bindings.push({ selector: `[data-hjx-id="${dataId}"]`, template: n.text });
      }
    }

    // element text content
    const inner = n.children?.length ? n.children.map(render).join("") : (n.text != null ? escapeTextWithInterpolation(n.text) : "");

    return `<${tag} ${attrParts.join(" ")}>${inner}</${tag}>`;
  }

  const htmlBody = render(node);
  return { htmlBody, bindings, eventBindings, inputBindings, ifForBindings };
}

function mapTag(tag: string): string {
  // limited set; allow raw html tags too
  const t = tag.toLowerCase();
  if (t === "view") return "div";
  if (t === "text") return "span";
  if (t === "button") return "button";
  if (t === "input") return "input";
  return t;
}

function escapeAttr(s: string): string {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTextWithInterpolation(s: string): string {
  // placeholders will be replaced by binder; keep as raw marker in text node
  // But we must escape HTML special chars.
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function vanillaRuntimeJS(): string {
  // runtime module exposed as ./runtime.js via blob URL in HTML
  // We'll create a module named runtime.js by injecting it into import map via dynamic module. For MVP simplicity:
  // We'll register a global object and app.js imports from "./runtime.js" will fail without bundler.
  // So we embed a tiny ES module loader shim that defines runtime as a module at runtime.
  // The devserver/build will also emit runtime.js file. This inline is just for the case you open index.html alone.
  return `
const runtimeCode = ${JSON.stringify(runtimeModuleSource())};
const blob = new Blob([runtimeCode], { type: "text/javascript" });
const runtimeUrl = URL.createObjectURL(blob);
window.__HJX_RUNTIME_URL__ = runtimeUrl;
`;
}

function runtimeModuleSource(): string {
  return `// HJX runtime v0.1
export function createStore(initial) {
  const state = { ...initial };
  const listeners = new Set();
  return {
    get: () => state,
    set: (patch) => { Object.assign(state, patch); listeners.forEach(fn => fn()); },
    subscribe: (fn) => { listeners.add(fn); return () => listeners.delete(fn); }
  };
}

export function textBinder(store, root, selector, template) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const out = template.replace(/\{\{\s*([A-Za-z_][A-Za-z0-9_]*)\s*\}\}/g, (_, key) => String(s[key] ?? ""));
    el.textContent = out;
  };
  render();
  store.subscribe(render);
}

export function clickBinder(store, root, selector, fn) {
  // delegated click handler so dynamically inserted elements work
  root.addEventListener("click", (e) => {
    const target = e.target;
    if (!target || !target.closest) return;
    const matched = target.closest(selector);
    if (matched) fn({ store, event: e, el: matched });
  });
}

export function inputBinder(store, root, selector, stateKey) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    if (el.value !== String(s[stateKey] ?? "")) el.value = String(s[stateKey] ?? "");
  };
  render();
  store.subscribe(render);
  el.addEventListener("input", (e) => {
    const v = e.target.value;
    store.set({ [stateKey]: v });
  });
}

// Control flow bindings
export function ifBinder(store, root, selector, condition) {
  const el = root.querySelector(selector);
  if (!el) return;
  const render = () => {
    const s = store.get();
    const result = evalCondition(condition, s);
    el.style.display = result ? "" : "none";
  };
  render();
  store.subscribe(render);
}

export function forBinder(store, root, selector, itemName, listName) {
  const container = root.querySelector(selector);
  if (!container) return;
  
  const render = () => {
    const s = store.get();
    const list = getPath(s, listName) || [];
    const tpl = container.querySelector('template');
    const templateHtml = tpl ? tpl.innerHTML : container.innerHTML;

    container.innerHTML = "";

    if (!Array.isArray(list)) return;

    list.forEach((item, idx) => {
      const itemState = { ...s, [itemName]: item };
      const itemHtml = templateHtml.replace(/\{\{\s*([A-Za-z_.][A-Za-z0-9_.]*\s*\}\}/g, (_, key) => {
        return String(getPath(itemState, key) ?? "");
      });
      const div = document.createElement("div");
      div.innerHTML = itemHtml;
      // attach item data so handlers can identify and manipulate it
      const itemStr = typeof item === 'string' ? item : JSON.stringify(item);
      div.querySelectorAll('[data-hjx-click]').forEach(el => {
        el.setAttribute('data-hjx-idx', String(idx));
        el.setAttribute('data-hjx-item', itemStr);
      });
      while (div.firstChild) container.appendChild(div.firstChild);
    });
  };
  
  render();
  store.subscribe(render);
}

function evalCondition(condition, state) {
  // Simple condition evaluator for state variables
  // Supports: varName, !varName, varName === value, etc
  const trimmed = condition.trim();
  
  if (trimmed.startsWith("!")) {
    return !evalCondition(trimmed.slice(1), state);
  }
  
  if (trimmed.includes("===")) {
    const [left, right] = trimmed.split("===").map(s => s.trim());
    return getPath(state, left) === parseValue(right);
  }
  
  if (trimmed.includes("==")) {
    const [left, right] = trimmed.split("==").map(s => s.trim());
    return getPath(state, left) == parseValue(right);
  }
  
  if (trimmed.includes("!=")) {
    const [left, right] = trimmed.split("!=").map(s => s.trim());
    return getPath(state, left) != parseValue(right);
  }
  
  // Default: treat as variable name
  return !!getPath(state, trimmed);
}

function getPath(obj, path) {
  return path.split(".").reduce((acc, part) => acc && acc[part], obj);
}

function parseValue(v) {
  const trimmed = v.trim();
  if (trimmed === "true") return true;
  if (trimmed === "false") return false;
  if (/^".*"$/.test(trimmed)) return trimmed.slice(1, -1);
  if (/^\\d+$/.test(trimmed)) return parseInt(trimmed);
  return trimmed;
}

// mount is kept for future
export function mount() {}
`;
}
